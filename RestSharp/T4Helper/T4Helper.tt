<#@ template language="C#v3.5" hostspecific="True" #>
<#@ output extension="log" #>
<#@ include file="T4Toolbox.tt" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
    // Requires T4Toolbox from http://t4toolbox.codeplex.com/ to be installed
    // Instructions: 
    // - Place this file and T4Toolbox.tt in a directory
    // - Select T4Toolbox.tt, go to the file Properties and clear out 'Custom Tool'
    // - Create an .rs file with sample XML for the class you want to generate
    // - Save this file to generate .cs file from .rs file or right click and select 'Run Custom Tool'
    // - Create dummy data in .rs file to get desired output
    // - Optionally set _namespace variable
    //   \/ \/ \/ \/ \/
    var _namespace = "";

    var currentDirectory = Path.GetDirectoryName(Host.TemplateFile);
    var restSharpSchemas = Directory.GetFiles(currentDirectory, "*.rs", SearchOption.AllDirectories);

    foreach (var file in restSharpSchemas)
    {
        string newFile = Path.Combine(Path.GetDirectoryName(file), Path.GetFileNameWithoutExtension(file) + ".cs");        
        RestSharpTemplate template = new RestSharpTemplate(file, _namespace);

        template.Output.File = newFile;
        template.Render();
    }
#>

<#+
public class RestSharpTemplate : T4Toolbox.Template
{
    protected string FilePath { get; set; }

    protected string Namespace { get; set; }

    public RestSharpTemplate(string file, string _namespace)
    {
        FilePath = file;
        Namespace = _namespace;
    }

    public override string TransformText()
    {
        // load file
        var doc = XDocument.Load(FilePath);
        RemoveNamespace(doc);

        // write header
        Write("using System;\r\n");
        Write("using System.Collections.Generic;");

        if (!string.IsNullOrEmpty(Namespace)) 
            Write(Environment.NewLine + "namespace " + Namespace + " {" + Environment.NewLine);

        Write(BuildClass(doc.Root));

        foreach (var item in Deferred.Reverse())
            Write(item.Value);

        if (!string.IsNullOrEmpty(Namespace))
            Write(Environment.NewLine + "}");

        return this.GenerationEnvironment.ToString();
    }

    string BuildClass(XElement root)
    {
        return BuildClass(root, false);
    }

    string BuildClass(XElement root, bool includeValueProp)
    {
        string valueProp = "";

        if (includeValueProp)
        {
            valueProp = string.Format("    public {0} Value {{ get; set; }}{1}", GuessType(root.Value), Environment.NewLine);
        }

        string classTemplate = @"
public class {0} {{
{1}{2}}}";

        System.Text.StringBuilder builder = new System.Text.StringBuilder();

        if (HasList(root))
        {
            AddListWithReference(root, builder);
        }
        else
        {
            builder.Append(BuildProperties(root));
        }

        return string.Format(classTemplate, ToPascalCase(root.Name), builder.ToString(), valueProp);
    }

    Dictionary<string, string> Deferred = new Dictionary<string, string>();

    string BuildProperties(XElement root)
    {
        var builder = new System.Text.StringBuilder();

        foreach (var el in root.Elements())
        {
            if (el.HasElements)
            {
                if (HasList(el))
                {
                    AddListWithReference(el, builder);
                }
                else
                {
                    AddClassWithReference(el, builder, false);
                }

                continue;
            }

            if (!el.HasElements && !el.HasAttributes)
            {
                builder.Append(BuildProperty(el));
                continue;
            }

            if ((!el.HasElements && el.HasAttributes))
            {
                bool includeValueProp = el.Value != null;

                AddClassWithReference(el, builder, includeValueProp);    
                continue;
            }
        }

        builder.Append(BuildAttributes(root));

        return builder.ToString();
    }

    bool HasList(XElement el)
    {
        return el.Elements().Count() > 1 && el.Elements().All(e => e.Name == el.Elements().First().Name);
    }

    void AddListWithReference(XElement el, System.Text.StringBuilder builder)
    {
        var first = el.Elements().First();

        if (!Deferred.ContainsKey(first.Name.ToString()))
        {
            Deferred.Add(first.Name.ToString(), BuildClass(first));
        }

        builder.AppendFormat("    public List<{0}.{1}> {2} {{ get; set; }}{3}", Namespace, ToPascalCase(first.Name), ToPascalCase(el.Name), Environment.NewLine);
    }

    void AddClassWithReference(XElement el, System.Text.StringBuilder builder, bool includeValueProp)
    {
        var name = el.Name.ToString();

        if (!Deferred.ContainsKey(name))
        {
            Deferred.Add(name, BuildClass(el, includeValueProp));
        }

        builder.AppendFormat("    public {0}.{1} {1} {{ get; set; }}{2}", Namespace, ToPascalCase(el.Name), Environment.NewLine);
    }

    string BuildProperty(XElement root)
    {
        return string.Format("    public {0} {1} {{ get; set; }}{2}", GuessType(root.Value), ToPascalCase(root.Name), Environment.NewLine);
    }

    string BuildAttributes(XElement root)
    {
        var builder = new System.Text.StringBuilder();

        foreach (var at in root.Attributes())
        {
            builder.AppendFormat("    public {0} {1} {{ get; set; }}{2}", GuessType(at.Value), ToPascalCase(at.Name), Environment.NewLine);
        }

        return builder.ToString();
    }

    string GuessType(string value)
    {
        bool boolVal;
        if (bool.TryParse(value, out boolVal))
            return typeof(bool).ToString();

        int intVal;
        if (int.TryParse(value, out intVal))
            return typeof(int).ToString();

        long longVal;
        if (long.TryParse(value, out longVal))
            return typeof(long).ToString();

        decimal decVal;
        if (decimal.TryParse(value, out decVal))
            return typeof(decimal).ToString();

        var dateFormats = new string[]
        {
            "u", 
            "s", 
            "yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'", 
            "yyyy-MM-ddTHH:mm:ssZ", 
            "yyyy-MM-dd HH:mm:ssZ", 
            "yyyy-MM-ddTHH:mm:ss", 
            "yyyy-MM-ddTHH:mm:sszzzzzz"
        };

        DateTime dateVal;
        if (DateTime.TryParseExact(value, dateFormats,
                                   System.Globalization.CultureInfo.InvariantCulture,
                                   System.Globalization.DateTimeStyles.None, out dateVal))
        {
            return typeof(DateTime).ToString();
        }

        // parse TimeSpan?
        return typeof(string).ToString();
    }

    void RemoveNamespace(XDocument xdoc)
    {
        foreach (XElement e in xdoc.Root.DescendantsAndSelf())
        {
            if (e.Name.Namespace != XNamespace.None)
            {
                e.Name = XNamespace.None.GetName(e.Name.LocalName);
            }
            if (e.Attributes().Where(a => a.IsNamespaceDeclaration || a.Name.Namespace != XNamespace.None).Any())
            {
                e.ReplaceAttributes(e.Attributes().Select(a => a.IsNamespaceDeclaration ? null : a.Name.Namespace != XNamespace.None ? new XAttribute(XNamespace.None.GetName(a.Name.LocalName), a.Value) : a));
            }
        }
    }

    string ToPascalCase(XName xname)
    {
        string text = xname.LocalName;
        bool removeUnderscores = true;

        if (String.IsNullOrEmpty(text))
            return text;

        text = text.Replace("_", " ");

        string joinString = removeUnderscores ? String.Empty : "_";
        string[] words = text.Split(' ');

        if (words.Length > 1 || IsUpperCase(words[0]))
        {
            for (int i = 0; i < words.Length; i++)
            {
                if (words[i].Length > 0)
                {
                    string word = words[i];
                    string restOfWord = word.Substring(1);

                    if (IsUpperCase(restOfWord))
                        restOfWord = restOfWord.ToLower(CultureInfo.CurrentUICulture);

                    char firstChar = char.ToUpper(word[0], CultureInfo.CurrentUICulture);
                    words[i] = String.Concat(firstChar, restOfWord);
                }
            }

            return String.Join(joinString, words);
        }

        return String.Concat(words[0].Substring(0, 1).ToUpper(CultureInfo.CurrentUICulture), words[0].Substring(1));
    }

    bool IsUpperCase(string inputString)
    {
        return Regex.IsMatch(inputString, @"^[A-Z]+$");
    }
}
#>
